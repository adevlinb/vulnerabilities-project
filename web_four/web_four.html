<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/styles.css">
    <title>Document</title>
</head>
<body>
    <div id="header">
        <h1>Host Cogent Vulnerabilities Project</h1>
    </div>
    <div id="main">
        <aside>
            <h3>Links to Results</h3>
            <div><a href="../index.html">HOME</a></div>
            <div><a href="../web_one/web_one.html">SITE ONE</a></div>
            <div><a href="../web_two/web_two.html">SITE TWO</a></div>
            <div><a href="../web_three/web_three.html">SITE THREE</a></div>
            <div><a href="../web_four/web_four.html">SITE FOUR</a></div>
        </aside>
        <section>
            <h3>Site Four: <small><a href="http://testaspnet.vulnweb.co" target="_blank">http://testaspnet.vulnweb.co</a></small></h3>
            <div>
                <h3>Technologies Used In This Site:</h3>
                <ul>
                    <details>
                        <summary>Tech <small>(scanned by <a href="https://zofixer.com/" target="_blank">zofixer.com:</a>)</small></summary>
                        <ul>
                            <li>Nginx</li>
                        </ul>
                    </details>
                </ul>
                <h3>Vulnerabilities to check for:</h3>
                <ul>
                    <details>
                        <summary>SQL Injection <span class="SQLI">(SQLI)</span></summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>"SQL Injection flaws are introduced when software developers create dynamic database queries constructed with string concatenation which includes user supplied input. To avoid SQL injection flaws is simple. Developers need to either: a) stop writing dynamic queries with string concatenation; and/or b) prevent user supplied input which contains malicious SQL from affecting the logic of the executed query."</p>
                            <small>From: <a href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html" target="_blank">OWASP SQL Injection Prevention</a></small>
                            <h3>Solution(s):</h3>
                            <h5>Parameterized Queries & Prepared Statements (server side)</h5>
                            <p>"SQL Injection is best prevented through the use of parameterized queries. The following chart demonstrates, with real-world code samples, how to build parameterized queries in most of the common web languages. The purpose of these code samples is to demonstrate to the web developer how to avoid SQL Injection when building database queries within a web application."</p>
                            <small>From <a href="https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html" target="_blank">OWASP CheatSheet Query Parameterization</a></small>
                            <small>Example of Parameterization in Java (server side)</small>
<pre><code>String custname = request.getParameter("customerName");
String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";
PreparedStatement pstmt = connection.prepareStatement( query );
pstmt.setString( 1, custname);
ResultSet results = pstmt.executeQuery( );</code></pre>
                            <h5>ORM - Object Relational Mapping (server side)</h5>
                            <p>"The use of an object-relational mapping (ORM) layer is also something you can consider. An ORM layer transforms the data from the database into objects and vise-versa. Using an ORM library reduces explicit SQL queries and, therefore, much less vulnerable to SQL injection."</p>
                            <small>From: <a href="https://www.globaldots.com/resources/blog/8-best-practices-to-prevent-sql-injection-attacks/#:~:text=Use%20an%20ORM%20layer,-The%20use%20of&text=An%20ORM%20layer%20transforms%20the,and%20Entity%20Framework%20for%20C%23." target="_blank">GlobalDots: 8 Best Practices To Prevent Injection</a></small>
                            <small>Exmaple from Django ORM</small>
                            <pre><code>Entry.objects.filter(pub_date__year=2006)</code></pre>
                            <p>Explanation: Because the orm accepts specific query parameters it does not open the door to the user being able to create / inject their on sql query that the database then executes. The information has to match the specific items being searched for through the ORM </p>
                            <h5>Input Validation(client side)</h5>
                            <p>The main line of defense on the client side to prevent sql injection is input validation. It is meant to be in addition to parameterization / use of an orm to perform sql queries. It is not a primary line of defense. That being said validation of the input can require the user to match specific information in the html so that can cannot just send whatever information they want to send. Validations can include: data type validators, arrays of allowed or hard-coded values, regular expressions for matching specific patterns, min or max values / ranges and many more. Validation can also be checked on the backend after the information is submitted.</p>
                            <small>Examples of HTML Input Validation:</small>
                            <pre><code>&lt;input type="text" id="choose" name="i-like" required minlength="6" maxlength="6" /&gt;</code></pre><br>
                            <pre><code>&lt;input type="number" id="number" name="amount" value="1" min="1" max="10" /&gt;</code></pre><br>
                            <pre><code>&lt;input id="choose" name="i-like" required pattern="[Bb]anana|[Cc]herry" /&gt;</code></pre>
                        </div>
                    </details>
                    <details>
                        <summary>Cross Site Scripting <span class="XSS">(XSS)</span></summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>"Cross-Site Scripting (XSS) is a misnomer. The name originated from early versions of the attack where stealing data cross-site was the primary focus. Since then, it has extended to include injection of basically any content, but we still refer to this as XSS. XSS is serious and can lead to account impersonation, observing user behaviour, loading external content, stealing sensitive data, and more."</p>
                            <small>From: <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#common-mistake" target="_blank">OWASP Cross Site Scripting Prevention</a></small>
                            <h3>Solution(s)</h3>
                            <h5>XSS Defense Philosophy</h5>
                            <p>"For XSS attacks to be successful, an attacker needs to insert and execute malicious content in a webpage. Each variable in a web application needs to be protected. Ensuring that all variables go through validation and are then escaped or sanitized is known as perfect injection resistance. Any variable that does not go through this process is a potential weakness. Frameworks make it easy to ensure variables are correctly validated and escaped or sanitised. However, frameworks aren't perfect and security gaps still exist in popular frameworks like React and Angular. Output Encoding and HTML Sanitization help address those gaps."</p>
                            <small>From: <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#common-mistake" target="_blank">OWASP Cross Site Scripting Prevention</a></small>
                            <h5>Output Encoding / Character Escaping, and Input Validation</h5>
                            <p>Output Encoding, Character Escaping, and Input Validation are top defensive strategies to minimize and prevent cross site scripting attacks. When user input that is being displayed as output to the UI there exists an opportunity for a user to type in code that can end up being run because the computer doesn't recognize or know that it is just meant to be displayed as a string, but truly ends up being run as code. Hijackers can exploit this by typing in the code they wish to run. For example</p>
                            <p>Most frameworks and frontend libraries have output character escaping / security measures built into their technologies. React and Django are two such examples. PHP however, does not.</p>
                            <h5>PHP Code Example For Hangling Output Character Escaping:</h5>
                            <p>PHP has functionality built into its system that allows for character escaping, but it is not automatically executed or used:</p>
                            <pre><code>&lt;?php function escape($string) { return htmlspecialchars($string, ENT_QUOTES) } ?&gt;</code></pre><br>
                            <pre><code>&lt;p&gt;Hello &lt;?php echo escape($name)?&gt;;&lt;p&gt;</code></pre>
                            <h5>Explanation:</h5>
                            <p>When a variable containing user or external input is going to be output in the UI.. if the output contains what looks like actual code (ex: &lt;script&gt;alert(1)&lt;script&gt;) that code will be read by the browser as being actual code to run unless those special html characters (and others) are intentionally told to output as actual test and not to turn it into code. </p>
                            <p>The output escaping function will parse / convert each variable / user info / output so that it cannot output anything other than a regular string. It is a primary layer of preventing cross site scripting. While user input can be filtered before saving to the database or returning the information back to the frontend, there are other ways to still directly change the output right before it is actually output. Therefore the best place to prevent XSS is right before it is actually output, like the given PHP example. React and Django Templating operate the same way of checking right before output.</p>
                            <p>An added level of security is input validation that forces a user to match specific parameters so random code is less likely to be input</p>
                            <p>We also have html sanitization. This process runs the entire html document through a function that will scan for unsafe or unwanted html or for what is deemed safe and parse out the opposite then returning the "sanitized" document. PHP has a strip_tags() function for example. This process does not always have the desired result as it can also stip wanted tags and code. The best approach is considered character escaping and focusing directly on where input/data is being out and displayed.</p>
                        </div>
                    </details>
                    <details>
                        <summary>Cross-Origin Resource Sharing <span class="CORS">(CORS)</span></summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>"Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources. CORS also relies on a mechanism by which browsers make a "preflight" request to the server hosting the cross-origin resource, in order to check that the server will permit the actual request. In that preflight, the browser sends headers that indicate the HTTP method and headers that will be used in the actual request."</p>
                            <small>From: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank"> Mozilla Developer Network: Cross-Origin Resource Sharing</a></small>
                        </div>
                    </details>
                    <details>
                        <summary>HTTPOnly Cookie <span class="HTTPOC">(HTTPOC)</span></summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Http Cookies: "An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests. Typically, an HTTP cookie is use to tell if two requests come from the same browser—keeping a user logged in, for example. It remembers stateful information for the stateless HTTP protocol."</p>
                            <small>From: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">Mozilla Developer Network: HTTP Cookies</a></small>
                            <p>"HttpOnly is an additional flag included in a Set-Cookie HTTP response header. Using the HttpOnly flag when generating a cookie helps mitigate the risk of client side script accessing the protected cookie (if the browser supports it)."</p>
                            <small>From: <a href="https://owasp.org/www-community/HttpOnly" target="_blank">OWASP HttpOnly</a></small>
                            <h3>Solution:</h3>
                            <p>HttpOnly is a security measure set by the Set-Cookie HTTP Response Header from the server. After examining the network tab in Chrome DevTools for request and response headers as well as the applications tab for any cookies being set, I did not find anything being set by this api. As a result there is not currently a specific cookie vulnerable to scripting attacks for this site. Additionally cookies are only an issue if the ones being set by the server have not been properly secured when setting the cookies in the response header. HttpOnly is just one of those mitigation tactics that can be used to help prevent Cross Site Scripting <span class="XSS">(XSS)</span>. "Cookies are also susceptible to CSRF (Cross-Site Request Forgery), XS-Leaks (Cross-Site Leaks), Network Attacks, and others." <small><a href="https://www.appsecmonkey.com/blog/cookie-security">App Sec Monkey</a></small> has an excellent site with explanation on Cookie Related Attacks and mitigation tactics for attacks beyond HttpOnly Cookie settings. HttpOnly settings are easily added by simply adding "HttpOnly" on the response header when setting the cookie.</p>
                            <small>Example of a secure cookie setup in response headers would be (based on <a href="https://www.appsecmonkey.com/blog/cookie-security" target="_blank">App Sec Monkey</a>):</small>
                            <pre><code>Set-Cookie: __Host-SessionId=s3cr3t; Secure; HttpOnly; SameSite=Lax; Path=/</code></pre>
                            <h3>Further notes:</h3>
                            <p>"According to Michael Howard, Senior Security Program Manager in the Secure Windows Initiative group at Microsoft, the majority of XSS attacks target theft of session cookies. A server could help mitigate this issue by setting the HttpOnly flag on a cookie it creates, indicating the cookie should not be accessible on the client. If a browser that supports HttpOnly detects a cookie containing the HttpOnly flag, and client side script code attempts to read the cookie, the browser returns an empty string as the result. This causes the attack to fail by preventing the malicious (usually XSS) code from sending the data to an attacker’s website."</p>
                            <small>From: <a href="https://owasp.org/www-community/HttpOnly#:~:text=If%20a%20browser%20does%20not,or%20modification%20by%20malicious%20script." target="_blank">OWASP HttpOnly</a></small>
                        </div>
                    </details>
                </ul>
            </div>
            <div>
                <h3>Vulnerabilities According to <small><a href="https://zofixer.com/" target="_blank">zofixer.com:</a></small></h3>
                <small>Click on the arrow next to the vulnerability to see an explanation and solutions:</small>
                <ul>
                    <details>
                        <summary>Content Security Policy Header Not Set <span class="XSS">(XSS)</span></summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>"The HTTP Content-Security-Policy response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (Cross-site_scripting)."</p>
                            <small>From <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank">Mozilla ContentSecurity Policy</a></small>
                            <p>To fix this we can set the content security policy in our application, server side by explicitly setting the policy on the response object that will be returned back to the client after a request is made. OR we can set it explicitly through a &lt;meta&gt; tag.</p>
                            <h3>Solutions(s) Server Side:</h3>
                            <p>For example... when working in NodeJS/ExpressJS we could do this in the server:</p>
                            <pre><code>res.set("Content-Security-Policy", "default-src 'self'");</code></pre>
                            <p>This will explicitly set the policy to say that a script can only be accepted from the same origin, which will help prevent cross site scripting. There all multiple other options that can be added on. There are also node packages that can be used specifically for setting the content policy...</p>
                            <pre><code>const { expressCspHeader, INLINE, NONE, SELF } = require('express-csp-header');<br>
app.use(expressCspHeader({
    directives: {
    'default-src': [SELF],
    'script-src': [SELF, INLINE, 'somehost.com'],
    'style-src': [SELF, 'mystyles.net'],
    'img-src': ['data:', 'images.com'],
    'worker-src': [NONE],
    'block-all-mixed-content': true
    }
}));</code></pre>
                            <h3>Solution(s) Client Side:</h3>
                            <p>And then in the browser we could also do:</p>
                            <pre><code>&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';"/&gt;</code></pre>
                            <small>Further Info: <a href="https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html" target="_blank">OWASP CheatSheeton Content-Security-Policy</a></small>
                        </div>
                    </details>
                    <details>
                        <summary>Missing Anti-clickjacking Header</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Absence of Anti-CSRF Tokens</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Server Leaks Version Information via “Server” HTTP Response Header Field</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Server Leaks Information via “X-Powered-By” HTTP Response Header Field(s)</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>X-Content-Type-Options Header Missing</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Cookie without SameSite Attribute</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Permissions Policy Header Not Set</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>X-AspNet-Version Response Header</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                    <details>
                        <summary>Cross-Domain JavaScript Source File Inclusion</summary>
                        <div class="details-box">
                            <h3>Explanation:</h3>
                            <p>Explanation...</p>
                            <h3>Solutions:</h3>
                            <p>Solutions with Code</p>
                        </div>
                    </details>
                </ul>
            </div>
            <div>
                <h3>Site Specific Solutions and Feedback:</h3>
            </div>
        </section>
    </div>
    <footer>
        <h5>[footer]</h5>
    </footer>
</body>
</html>
